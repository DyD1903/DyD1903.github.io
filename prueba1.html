<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Fuerza Roja</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Rubik+Mono+One&display=swap" rel="stylesheet">
  <link href="style.css" rel="stylesheet">
</head>
<body>
  <div class="hero">
    <canvas id="gooey-overlay"></canvas>
    <div class="hero-content">
      <h1 class="hero-title">FUERZA ROJA</h1>
      <div class="hero-subtitle">TU SALUD NOS IMPORTA POR ESO CALCULA SI TIENES ANEMIA</div>
      <a href="/imagenes/usuario.html" class="btn btn-fuerza">Inicio sesi√≥n / Registrarse</a>
    </div>
    <a href="index.html" class="descubrir-btn">
      <i class="fas fa-angle-double-down"></i> DESCUBRIR
    </a>
  </div>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>
  <script id="vertShader" type="x-shader/x-fragment">
    attribute vec2 a_position;
    varying vec2 vUv;
    void main() {
      vUv = a_position * 0.5 + 0.5;
      gl_Position = vec4(a_position, 0.0, 1.0);
    }
  </script>
  <script id="fragShader" type="x-shader/x-fragment">
    precision mediump float;
    varying vec2 vUv;
    uniform vec2 u_resolution;
    uniform float u_scroll_progr;
    uniform float u_col_width;
    uniform float u_seed;
    uniform float u_scale;
    uniform float u_time;
    uniform float u_speed;
    uniform vec3 u_color;
    vec3 mod289(vec3 x){return x-floor(x*(1.0/289.0))*289.0;}
    vec2 mod289(vec2 x){return x-floor(x*(1.0/289.0))*289.0;}
    vec3 permute(vec3 x){return mod289(((x*34.0)+1.0)*x);}
    float snoise(vec2 v){
      const vec4 C=vec4(.211324865405187,.366025403784439,-.577350269189626,.024390243902439);
      vec2 i=floor(v+dot(v,C.yy));
      vec2 x0=v-i+dot(i,C.xx);
      vec2 i1=(x0.x>x0.y)?vec2(1.,0.):vec2(0.,1.);
      vec4 x12=x0.xyxy+C.xxzz;
      x12.xy-=i1;
      i=mod289(i);
      vec3 p=permute(permute(i.y+vec3(0.,i1.y,1.))+i.x+vec3(0.,i1.x,1.));
      vec3 m=max(.5-vec3(dot(x0,x0),dot(x12.xy,x12.xy),dot(x12.zw,x12.zw)),0.);
      m*=m;m*=m;
      vec3 x=2.*fract(p*C.www)-1.;
      vec3 h=abs(x)-.5;
      vec3 ox=floor(x+.5);
      vec3 a0=x-ox;
      m*=1.79284291400159-.85373472095314*(a0*a0+h*h);
      vec3 g;
      g.x=a0.x*x0.x+h.x*x0.y;
      g.yz=a0.yz*x12.xz+h.yz*x12.yw;
      return 130.*dot(m,g);
    }
    float get_l(vec2 v){return 1.-clamp(0.,1.,length(v));}
    float rand(float n){return fract(sin(n)*43758.5453123);}
    void main(){
      float scale=.001*u_scale;
      float speed=.001*u_speed;
      vec2 uv=vUv;
      uv.x*=(scale*u_resolution.x);
      vec2 noise_uv=uv;
      noise_uv*=5.;
      noise_uv.y*=(.25*scale*u_resolution.y);
      noise_uv+=vec2(0.,u_time*1.5*speed);
      float shape=0.;
      shape+=snoise(noise_uv);
      shape=clamp(.5+.5*shape,0.,1.);
      shape*=pow(.5*uv.y+.7+pow(u_scroll_progr,2.)+(.4*u_scroll_progr*(1.-pow(vUv.x-.2,2.))),10.);
      shape=clamp(shape,0.,1.);
      float dots=0.;
      float bars=0.;
      float light=0.;
      const int num_col=9;
      for(int i=0;i<num_col;i++){
        vec2 col_uv=vUv;
        float start_time_offset=rand(100.*(float(i)+u_seed));
        float c_t=fract(u_time*speed+start_time_offset);
        float drop_time=.2+.6*rand(10.*(float(i)+u_seed));
        float before_drop_normal=c_t/drop_time;
        float before_drop_t=pow(before_drop_normal,.4)*drop_time;
        float after_drop_normal=max(0.,c_t-drop_time)/(1.-drop_time);
        float after_drop_t_dot=3.*pow(after_drop_normal,2.)*(1.-drop_time);
        float after_drop_t_bar=pow(after_drop_normal,2.)*(drop_time);
        float eased_drop_t=step(c_t,drop_time)*before_drop_t;
        eased_drop_t+=step(drop_time,c_t)*(drop_time+after_drop_t_dot);
        col_uv.y+=(1.+3.*rand(15.*float(i)))*u_scroll_progr;
        col_uv.x*=(u_resolution.x/u_resolution.y);
        col_uv*=(7.*scale*u_resolution.y);
        col_uv.x+=(u_col_width*(.5*float(num_col)-float(i)));
        vec2 dot_uv=col_uv;
        dot_uv.y+=4.*(eased_drop_t-.5);
        float dot=get_l(dot_uv);
        dot=pow(dot,4.);
        float drop_grow=step(c_t,drop_time)*pow(before_drop_normal,.4);
        drop_grow+=step(drop_time,c_t)*mix(1.,.8,clamp(7.*after_drop_normal,0.,1.));
        dot*=drop_grow;
        dot*=step(.5,drop_time);
        dots+=dot;
        vec2 bar_uv=col_uv;
        bar_uv.y+=step(c_t,drop_time)*4.*(before_drop_t-.5);
        bar_uv.y+=step(drop_time,c_t)*4.*(drop_time-after_drop_t_bar-.5);
        float bar=smoothstep(-.5,0.,bar_uv.x)*(1.-smoothstep(0.,.5,bar_uv.x));
        bar=pow(bar,4.);
        light+=bar*smoothstep(.0,.1,-bar_uv.x);
        float bar_mask=smoothstep(-.2,.2,bar_uv.y);
        bar*=bar_mask;
        bars+=bar;
      }
      shape+=bars;
      shape=clamp(shape,0.,1.);
      shape+=dots;
      float gooey=smoothstep(.48,.5,shape);
      gooey-=.1*smoothstep(.5,.6,shape);
      // Tonalidades de sangre:
      vec3 sangre1 = vec3(0.8, 0.1, 0.18); // rojo sangre
      vec3 sangre2 = vec3(0.5, 0.02, 0.08); // rojo oscuro
      vec3 color = mix(sangre1, sangre2, vUv.y);
      color *= gooey;
      color = mix(color, vec3(1.), max(0.,1.-2.*vUv.y)*light*smoothstep(.1,.7,snoise(.5*uv))*(smoothstep(.49,.6,shape)-smoothstep(.6,1.,shape)));
      gl_FragColor=vec4(color,gooey);
    }
  </script>
  <script type="module">
    const canvasEl = document.querySelector("#gooey-overlay");
    const hero = document.querySelector(".hero");
    const devicePixelRatio = Math.min(window.devicePixelRatio,2);
    const params = {
      colWidth:.7,
      speed:.2,
      scale:.25,
      seed:.231,
      color:[0.8,0.1,0.18], // rojo sangre
      pageColor:"#f5e9da"
    };
    let uniforms;
    const gl = initShader();
    document.body.style.backgroundColor=params.pageColor;
    window.addEventListener("resize",resizeCanvas);
    resizeCanvas();
    render();
    function initShader(){
      const vsSource=document.getElementById("vertShader").textContent,
            fsSource=document.getElementById("fragShader").textContent;
      const gl = canvasEl.getContext("webgl") || canvasEl.getContext("experimental-webgl");
      if(!gl){alert("WebGL no soportado");}
      function createShader(gl,src,type){
        const shader=gl.createShader(type);
        gl.shaderSource(shader,src);
        gl.compileShader(shader);
        if(!gl.getShaderParameter(shader,gl.COMPILE_STATUS)){
          console.error("Shader compile error:",gl.getShaderInfoLog(shader));
          gl.deleteShader(shader);
          return null;
        }
        return shader;
      }
      const vertexShader   = createShader(gl,vsSource,gl.VERTEX_SHADER);
      const fragmentShader = createShader(gl,fsSource,gl.FRAGMENT_SHADER);
      const program = gl.createProgram();
      gl.attachShader(program,vertexShader);
      gl.attachShader(program,fragmentShader);
      gl.linkProgram(program);
      if(!gl.getProgramParameter(program,gl.LINK_STATUS)){
        console.error("Shader link error:",gl.getProgramInfoLog(program));
      }
      gl.useProgram(program);
      uniforms={};
      const uniformCount=gl.getProgramParameter(program,gl.ACTIVE_UNIFORMS);
      for(let i=0;i<uniformCount;i++){
        const name=gl.getActiveUniform(program,i).name;
        uniforms[name]=gl.getUniformLocation(program,name);
      }
      const vertices=new Float32Array([-1,-1,1,-1,-1,1,1,1]);
      const vbo=gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER,vbo);
      gl.bufferData(gl.ARRAY_BUFFER,vertices,gl.STATIC_DRAW);
      const posLoc=gl.getAttribLocation(program,"a_position");
      gl.enableVertexAttribArray(posLoc);
      gl.vertexAttribPointer(posLoc,2,gl.FLOAT,false,0,0);
      gl.uniform1f(uniforms.u_col_width, params.colWidth);
      gl.uniform1f(uniforms.u_speed,     params.speed);
      gl.uniform1f(uniforms.u_scale,     params.scale);
      gl.uniform1f(uniforms.u_seed,      params.seed);
      return gl;
    }
    function render(){
      const t=performance.now();
      gl.uniform1f(uniforms.u_time,t);
      gl.uniform1f(uniforms.u_scroll_progr,0);
      gl.drawArrays(gl.TRIANGLE_STRIP,0,4);
      requestAnimationFrame(render);
    }
    function resizeCanvas(){
      canvasEl.width  = hero.offsetWidth  * devicePixelRatio;
      canvasEl.height = hero.offsetHeight * devicePixelRatio;
      gl.viewport(0,0,canvasEl.width,canvasEl.height);
      gl.uniform2f(uniforms.u_resolution,canvasEl.width,canvasEl.height);
    }
  </script>
</body>
</html>
